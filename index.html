<html>
<head>
	<script type="text/javascript" src="crafty-min.js"></script>
	<script type="text/javascript" src="map.js"></script>
</head>
  	<style>
  	body {
  		background:#000;
  	}
  	#game
	{
	    display: block;
	    margin: 0px auto;
	    background:#000 url(imgs/floor.png) center center;
	}
  	</style>
<body>dsa
	<div id="game"></div>
	<script type="text/javascript">
		var dimensions = 30;

		Crafty.sprite(48, 'imgs/brandon.png', {
			PlayerSprite:[0, 0]
		})

		Crafty.c('Player', {
		    // This function will be called when the component is added to an entity
		    // So it sets up the things that both our entities had in common
		    init: function() {
		        this.addComponent('2D, Canvas, Fourway, Keyboard, SpriteAnimation, PlayerSprite');
		        this.reel('PlayerIdle',500, 0, 0, 3);
		        this.reel('PlayerWeaponSelect',500, 0, 1, 3);
		        this.reel('PlayerDown',500, 0, 2, 3);
		        this.reel('PlayerSide',500, 0, 3, 3);
		        this.reel('PlayerUp',500, 0, 4, 3);
		        this.reel('PlayerAttackDown',500, 0, 5, 3);
		        this.reel('PlayerAttackSide',500, 0, 6, 3);
		        this.reel('PlayerAttackUp',500, 0, 7, 3);
		     	this.hitbox = Crafty.e('2D, Canvas, Color, Collision, PlayerHitArea');
		        this.state = 'PlayerIdle';
				this.animate(this.state, -1);

		        this.fourway(100)
		        this.w = 16;
		        this.h = 16;
		        this.game = null;
		        this.camera = false;
		        this.collide = false;
		       
		        Crafty.viewport.clampToEntities = false;
  	 	 		Crafty.viewport.bounds = {min:{x:0, y:0}, max:{x:20, y:20}};
  	 	 		Crafty.viewport.clampToEntities = false;
				//Crafty.viewport.follow(this);
				//Crafty.viewport.scale(8);

		        this.bind('Move', function(evt) {
		        	this.hitbox.attr({x: (this.x + this.w / 2) - 3, y: (this.y + this.h / 2) - 3, w: 5, h: 6});

		        	if(this.collide == false) {
		        		return;
		        	}

					var wallCollisions = this.hitbox.hit('Wall');
					var endCollisions = this.hitbox.hit('EndPoint');
					if(wallCollisions) {
					    var wallCollisionData = wallCollisions[0];
				  		this.x -= wallCollisionData.overlap * wallCollisionData.nx;
	    				this.y -= wallCollisionData.overlap * wallCollisionData.ny;

	    				this.hitbox.x -= wallCollisionData.overlap * wallCollisionData.nx;
	    				this.hitbox.y -= wallCollisionData.overlap * wallCollisionData.ny;
	    			} else if(endCollisions) {
						Crafty.enterScene('GameStart');
	    			}
				});

				this.bind('UpdateFrame', function() {
	
					var k = false;
					var state = 'PlayerIdle';
					if (Crafty.s('Keyboard').isKeyDown('A')||Crafty.s('Keyboard').isKeyDown('LEFT_ARROW')) {
						k = true;
						state = 'PlayerSide';
						this.flip('X');
					}
			  		if (Crafty.s('Keyboard').isKeyDown('D')||Crafty.s('Keyboard').isKeyDown('RIGHT_ARROW')) {
			  			k = true;
			  			state = 'PlayerSide';
					    this.unflip('X');
			  		}

					if (Crafty.s('Keyboard').isKeyDown('W')||Crafty.s('Keyboard').isKeyDown('UP_ARROW')) { 
						k = true;
						state = 'PlayerUp';
					}
	
					if (Crafty.s('Keyboard').isKeyDown('S')||Crafty.s('Keyboard').isKeyDown('DOWN_ARROW')) {
						k = true;
						state = 'PlayerDown';
					}

					if (Crafty.s('Keyboard').isKeyDown('SPACE')) {
						k = true;
						if(state == 'PlayerIdle'){
							state = 'PlayerWeaponSelect';
						}
						else if(state == 'PlayerUp'){
							state = 'PlayerAttackUp';
						}
						else if(state == 'PlayerDown'){
							state = 'PlayerAttackDown';
						}
						else if(state == 'PlayerUp'){
							state = 'PlayerAttackUp';
						}
						else if(state == 'PlayerSide'){
							state = 'PlayerAttackSide';
						}
					}

				    if(k && this.state != state) {
				    	this.state = state;
			    		this.animate(state, -1);
			    	} else if(k == false && this.state != state) { // go back to idle
			    		this.state = 'PlayerIdle';
			    		this.animate('PlayerIdle', -1);
			    	}

					/*
				  	if (Crafty.s('Keyboard').isKeyDown('C')) {
				 
				  		if(this.camera) {
							Crafty.viewport.clampToEntities = false;
		      	 	 		Crafty.viewport.bounds = {min:{x:0, y:0}, max:{x:20, y:20}};
		      	 	 		Crafty.viewport.clampToEntities = false;
							Crafty.viewport.follow(this);
							Crafty.viewport.scale(8);
						} else {
							Crafty.viewport.scale(0);
						}
					}

					*/

				});

				this.bind('KeyUp', function(e) {
					   this.camera = !this.camera;
				});
		    },
		});


		 var game = new function() {
		 	this.tile = 20;
		 	this.map = [];

		 	// scenes
		 	this.gameStart = function() {
				Crafty.init(dimensions * this.tile, dimensions * this.tile, document.getElementById('game'));
				this.renderMap();
				this.placeStartPoint();
				this.placeEndPoint();
			},

			this.placeStartPoint = function() {
				var placed = false;
				this.getMap(function(x,y,value, type) {
					var rx = Math.floor(Math.random() * 6) + 1;
					var ry = Math.floor(Math.random() * 6) + 1;

					if(value == 0 && placed == false) {
						if(x >= rx && y >= ry) {
							placed = true;
							Crafty.e('2D, Canvas, Color').attr({x: x * this.tile, y: y * this.tile, w: this.tile, h: this.tile}).color('#0f0');
							var player = Crafty.e('Player').attr({x: x * this.tile, y: y * this.tile});
							player.collide = true;
							player.game = this;
						}
					}
				}.bind(this));
			},

			this.placeEndPoint = function() {
				var placed = false;
				this.getMap(function(x,y,value, type) {
					var rx = Math.floor(Math.random() * this.tile) + (this.tile / 3);
					var ry = Math.floor(Math.random() * this.tile) + (this.tile / 2);

					if(value == 0 && placed == false) {
						if(x >= rx && y >= ry) {
							placed = true;
							Crafty.e('2D, Canvas, Color, Collision, EndPoint').attr({x: x * this.tile, y: y * this.tile, w: this.tile, h: this.tile}).color('#f00');
						}
					}
				}.bind(this));
			},

			this.renderMap = function() {
				this.map = createMap();
				this.getMap(function(x,y,value, type) {
					if(value == 1) {
						if(type == 'all') {
							Crafty.e('2D, Canvas, Color').attr({x: x * this.tile, y: y * this.tile, w: this.tile, h: this.tile}).color('#f90');
						} else {
							Crafty.e('2D, Canvas, Color, Collision, WiredHitBox, Wall').attr({x: x * this.tile, y: y * this.tile, w: this.tile, h: this.tile}).color('#f90');
						}
					}
				}.bind(this));
			},

			this.getMap = function(callback) {
				for(var x = 0; x < this.map.length; x++) { // row
					for(var y = 0; y < this.map.length; y++) { // cols
						//console.log(map[i][j]);
						callback(x,y, this.map[x][y], this.getTileType(x,y));
					}
				}
		 	},

		 	this.getTileType = function(x,y) {
		 		var g = '';
				try {
					if(this.map[x-1][y] != 1) // top border
						g += 'top';
				} catch(e) {}

				try {
					if(this.map[x][y+1] != 1) // rxght border
						g += 'right'
				} catch(e) {}

				try {
					if(this.map[x+1][y] != 1) // bottom border
						g += 'bottom'
				} catch(e) {}

				try {
					if(this.map[x][y-1] != 1) // left border
						g += 'left';
				} catch(e) {}

				if(g == '') {
					g = 'all'
				}
				return g;
		 	},

		 	this.mainMenu = function() {
		 		Crafty.init(dimensions * this.tile, dimensions * this.tile, document.getElementById('game'));
		 		Crafty.e('2D, Canvas, Image').image('imgs/main_menu.png').attr({w: 600, h: 600})
		 		 .bind('KeyDown', function(e) {
				    if (e.key == Crafty.keys.ENTER) {
				      Crafty.enterScene('GameStart');
				    }
				  });
		 	},

		 	this.gameOver = function() {
				Crafty.background('#000');
				Crafty.e('2D, DOM, Text')
				      .attr({ w: 100, h: 20, x: 150, y: 120 })
				      .text('Game Over')
				      .textAlign('center')
				      .textColor('#FFFFFF');
		 	}
		 }
	
		Crafty.defineScene('MainMenu', game.mainMenu.bind(game));
		Crafty.defineScene('GameOver', game.gameOver.bind(game));
		Crafty.defineScene('GameStart', game.gameStart.bind(game));
		Crafty.enterScene('MainMenu');
	</script>
</body>
</html>